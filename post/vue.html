<!DOCTYPE html>
<html lang="ch">
<head>
  <title>vue</title>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">

  <style>
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/

    body {
      font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
      font-size: 14px;
      padding: 0 12px;
      line-height: 22px;
      word-wrap: break-word;
    }

    #code-csp-warning {
      position: fixed;
      top: 0;
      right: 0;
      color: white;
      margin: 16px;
      text-align: center;
      font-size: 12px;
      font-family: sans-serif;
      background-color:#444444;
      cursor: pointer;
      padding: 6px;
      box-shadow: 1px 1px 1px rgba(0,0,0,.25);
    }

    #code-csp-warning:hover {
      text-decoration: none;
      background-color:#007acc;
      box-shadow: 2px 2px 2px rgba(0,0,0,.25);
    }


    body.scrollBeyondLastLine {
      margin-bottom: calc(100vh - 22px);
    }

    body.showEditorSelection .code-line {
      position: relative;
    }

    body.showEditorSelection .code-active-line:before,
    body.showEditorSelection .code-line:hover:before {
      content: "";
      display: block;
      position: absolute;
      top: 0;
      left: -12px;
      height: 100%;
    }

    body.showEditorSelection li.code-active-line:before,
    body.showEditorSelection li.code-line:hover:before {
      left: -30px;
    }

    .vscode-light.showEditorSelection .code-active-line:before {
      border-left: 3px solid rgba(0, 0, 0, 0.15);
    }

    .vscode-light.showEditorSelection .code-line:hover:before {
      border-left: 3px solid rgba(0, 0, 0, 0.40);
    }

    .vscode-dark.showEditorSelection .code-active-line:before {
      border-left: 3px solid rgba(255, 255, 255, 0.4);
    }

    .vscode-dark.showEditorSelection .code-line:hover:before {
      border-left: 3px solid rgba(255, 255, 255, 0.60);
    }

    .vscode-high-contrast.showEditorSelection .code-active-line:before {
      border-left: 3px solid rgba(255, 160, 0, 0.7);
    }

    .vscode-high-contrast.showEditorSelection .code-line:hover:before {
      border-left: 3px solid rgba(255, 160, 0, 1);
    }

    img {
      max-width: 100%;
      max-height: 100%;
    }

    a {
      color: #4080D0;
      text-decoration: none;
    }

    a:focus,
    input:focus,
    select:focus,
    textarea:focus {
      outline: 1px solid -webkit-focus-ring-color;
      outline-offset: -1px;
    }

    hr {
      border: 0;
      height: 2px;
      border-bottom: 2px solid;
    }

    h1 {
      padding-bottom: 0.3em;
      line-height: 1.2;
      border-bottom-width: 1px;
      border-bottom-style: solid;
    }

    h1, h2, h3 {
      font-weight: normal;
    }

    h1 code,
    h2 code,
    h3 code,
    h4 code,
    h5 code,
    h6 code {
      font-size: inherit;
      line-height: auto;
    }

    a:hover {
      color: #4080D0;
      text-decoration: underline;
    }

    table {
      border-collapse: collapse;
    }

    table > thead > tr > th {
      text-align: left;
      border-bottom: 1px solid;
    }

    table > thead > tr > th,
    table > thead > tr > td,
    table > tbody > tr > th,
    table > tbody > tr > td {
      padding: 5px 10px;
    }

    table > tbody > tr + tr > td {
      border-top: 1px solid;
    }

    blockquote {
      margin: 0 7px 0 5px;
      padding: 0 16px 0 10px;
      border-left: 5px solid;
    }

    code {
      font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
      font-size: 14px;
      line-height: 19px;
    }

    body.wordWrap pre {
      white-space: pre-wrap;
    }

    .mac code {
      font-size: 12px;
      line-height: 18px;
    }

    pre:not(.hljs),
    pre.hljs code > div {
      padding: 16px;
      border-radius: 3px;
      overflow: auto;
    }

    /** Theming */

    .vscode-light,
    .vscode-light pre code {
      color: rgb(30, 30, 30);
    }

    .vscode-dark,
    .vscode-dark pre code {
      color: #DDD;
    }

    .vscode-high-contrast,
    .vscode-high-contrast pre code {
      color: white;
    }

    .vscode-light code {
      color: #A31515;
    }

    .vscode-dark code {
      color: #D7BA7D;
    }

    .vscode-light pre:not(.hljs),
    .vscode-light code > div {
      background-color: rgba(220, 220, 220, 0.4);
    }

    .vscode-dark pre:not(.hljs),
    .vscode-dark code > div {
      background-color: rgba(10, 10, 10, 0.4);
    }

    .vscode-high-contrast pre:not(.hljs),
    .vscode-high-contrast code > div {
      background-color: rgb(0, 0, 0);
    }

    .vscode-high-contrast h1 {
      border-color: rgb(0, 0, 0);
    }

    .vscode-light table > thead > tr > th {
      border-color: rgba(0, 0, 0, 0.69);
    }

    .vscode-dark table > thead > tr > th {
      border-color: rgba(255, 255, 255, 0.69);
    }

    .vscode-light h1,
    .vscode-light hr,
    .vscode-light table > tbody > tr + tr > td {
      border-color: rgba(0, 0, 0, 0.18);
    }

    .vscode-dark h1,
    .vscode-dark hr,
    .vscode-dark table > tbody > tr + tr > td {
      border-color: rgba(255, 255, 255, 0.18);
    }

    .vscode-light blockquote,
    .vscode-dark blockquote {
      background: rgba(127, 127, 127, 0.1);
      border-color: rgba(0, 122, 204, 0.5);
    }

    .vscode-high-contrast blockquote {
      background: transparent;
      border-color: #fff;
    }
  </style>

  <style>
    /* Tomorrow Theme */
    /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
    /* Original theme - https://github.com/chriskempson/tomorrow-theme */

    /* Tomorrow Comment */
    .hljs-comment,
    .hljs-quote {
      color: #8e908c;
    }

    /* Tomorrow Red */
    .hljs-variable,
    .hljs-template-variable,
    .hljs-tag,
    .hljs-name,
    .hljs-selector-id,
    .hljs-selector-class,
    .hljs-regexp,
    .hljs-deletion {
      color: #c82829;
    }

    /* Tomorrow Orange */
    .hljs-number,
    .hljs-built_in,
    .hljs-builtin-name,
    .hljs-literal,
    .hljs-type,
    .hljs-params,
    .hljs-meta,
    .hljs-link {
      color: #f5871f;
    }

    /* Tomorrow Yellow */
    .hljs-attribute {
      color: #eab700;
    }

    /* Tomorrow Green */
    .hljs-string,
    .hljs-symbol,
    .hljs-bullet,
    .hljs-addition {
      color: #718c00;
    }

    /* Tomorrow Blue */
    .hljs-title,
    .hljs-section {
      color: #4271ae;
    }

    /* Tomorrow Purple */
    .hljs-keyword,
    .hljs-selector-tag {
      color: #8959a8;
    }

    .hljs {
      display: block;
      overflow-x: auto;
      color: #4d4d4c;
      padding: 0.5em;
    }

    .hljs-emphasis {
      font-style: italic;
    }

    .hljs-strong {
      font-weight: bold;
    }
  </style>

  <style>
    /*
     * Markdown PDF CSS
     */

    body {
      font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
    }

    pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      border-radius: 3px;
      overflow-x: auto;
      white-space: pre-wrap;
      overflow-wrap: break-word;
    }

    pre:not(.hljs) {
      padding: 23px;
      line-height: 19px;
    }

    blockquote {
      background: rgba(127, 127, 127, 0.1);
      border-color: rgba(0, 122, 204, 0.5);
    }

    .emoji {
      height: 1.4em;
    }

    /* for inline code */
    :not(pre):not(.hljs) > code {
      color: #C9AE75; /* Change the old color so it seems less like an error */
      font-size: inherit;
    }

    /* Page Break : use <div class="page"/> to insert page break
    -------------------------------------------------------- */
    .page {
      page-break-after: always;
    }

  </style>

</head>
<body>
<h1 id="vue">vue</h1>
<h2 id="%E6%A1%86%E6%9E%B6-%E5%AF%B9%E6%AF%94-jquery-%E5%8E%9F%E7%94%9F-dom">框架 对比 jquery 原生 dom</h2>
<ol>
  <li>原生 dom 优点 不用导入任何的框架 插件，跨平台好，在操作 dom 时相对麻烦，</li>
  <li>jquery 中，相对于 原生 dom 更加方便，对 dom 的每一个 api 进行了简化，但是任然需操作到 dom</li>
  <li>框架 优点 彻底简化了开发的步骤，基本上不需要操作 dom， 这种优化，需要转变之前的观念</li>
</ol>
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF-vue">什么是 Vue</h2>
<ol>
  <li>Vue 是基于 MVVM 设计模式的渐进式的前端 js 框架
    <ul>
      <li>渐进式: 可以有选择的逐步使用框架中的组件,可以配合其他组件 js 库使用; 全家桶: 必须全盘使用所有组件</li>
      <li>前端 js 框架，不需要使用 nodejs 但是需要使用到中的 babel 编译 ex6 中的浏览器不认识的语音，</li>
    </ul>
  </li>
  <li>侧重于以数据操作为主的前端项目开发</li>
</ol>
<h2 id="mvvm-%E5%8E%9F%E7%90%86"><code>MVVM</code> 原理</h2>
<ol>
  <li>
    <p><code>MVVM</code> 设计模式 ：设计模式将前端的内容重新划分：（步骤）</p>
    <ol>
      <li>界面(view) html css 为 html 中 添加了动态功能的功能 有变量 if else for 等功能</li>
      <li>数据模型 model 所页面上需要的可能发生变化的数据。 集中定义在 data 中</li>
      <li>控制器(view model) 将视图 view 和模型数据(model) 绑定在一起 (视图和模型中的数据保持同步)</li>
    </ol>
  </li>
  <li>
    <p>控制器 viewModel 中包含有两大系统</p>
    <ol>
      <li>响应系统: 监控模型中每个变量的变化
        <ol>
          <li>将 data 中每个属性都提升为 new Vue 对象的访问属性，只要修改了 new Vue 对象中访问器属性。就会同时的向虚拟 dom 树发出通知</li>
        </ol>
      </li>
      <li>虚拟 DOM 树:
        <ol>
          <li>虚拟 dom 树 是 Vue 临时生成的仅仅保存可能变化的元素和属性</li>
          <li>在 new Vue 是会生成 边遍历受控制的元素，边生成，也会封装了 DOM 方法，</li>
          <li>当响应系统通知某个变量被修改时，虚拟 dom 树会快速的遍历自身，找到别修改的 DOM 元素，仅仅修改 被修改的 DOM 元素</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>
<h3 id="%E8%99%9A%E6%8B%9F-dom-%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9">虚拟 dom 树的优点</h3>
<ol>
  <li>内容少，速度快，仅仅修改需要改变的 DOM 不会先 jq 中的更多无关的元素被修改</li>
</ol>
<h2 id="%E4%BD%BF%E7%94%A8---vue-%E5%AE%98%E6%96%B9"><a href="https://cn.vuejs.org/">使用-- vue 官方</a></h2>
<ol>
  <li>
    <p>下载（开发版 没有压缩，生成版：代码没有压缩，删除了所有注释和错误的提示）</p>
    <ol>
      <li>下载独立的 vue.js 直接在网页引入</li>
      <li>脚手架</li>
    </ol>
  </li>
</ol>
<h2 id="%E8%AF%AD%E6%B3%95">语法</h2>
<h3 id="%E5%88%9B%E5%BB%BA-vue-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">创建 vue 的实例对象</h3>
<ol>
  <li>对象中的属性 data methods prop 等</li>
</ol>
<h3 id="%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</h3>
<ol>
  <li>{{}} 正确的 sj 有返回值的 变量 表达式 函数等 模板字符串等 只能绑定内容 不能绑定属性，事件等。。</li>
</ol>
<h3 id="%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4">基本指令</h3>
<ol>
  <li>
    <p>v-text 绑定数据，渲染到元素中，会替换内容</p>
  </li>
  <li>
    <p>v-bind:propName=&quot;js 表达式&quot; 简写:propName=&quot;js 表达式&quot; 绑定属性</p>
  </li>
  <li>
    <p>绑定事件 @click='处理函数名' v-on:click=&quot;处理函数名&quot; 也可传入参数 @click='处理函数名(参数 1,参数 2..., $event)'  $event 是事件处理参数</p>
  </li>
  <li>
    <p>控制显示与隐藏， v-if=&quot;判断条件&quot; v-else v-else-if=&quot;条件&quot; 创建或删除元素 也可以使用 v-show 控制 display 的</p>
  </li>
  <li>
    <p>v-for 反复生成相同结构的元素 v-for=&quot;(item, index) of 数组&quot; 需要给循环的每一项加下:key 标识</p>
  </li>
  <li>
    <p>v-html 绑定 html 片段</p>
  </li>
  <li>
    <p>v-cloak 在页面没有加载完成时，使用 v-cloak 这个属性在页面渲染完成的时候会移除，可以在在 css 中，设置<code>[v-cloak]{ display: none;}</code>,隐藏 在页面渲染后就会自动的移除这个属性</p>
  </li>
  <li>
    <p>v-pre 用于绑定 内容中{{}}不被浏览器编译,而保持原样显示</p>
  </li>
  <li>
    <p>v-once 当元素加上这个属性时， 这个元素在第一次加载完成后，标签中的内容不会随 data 的改变而改变 断开数据的绑定，在虚拟 dom 数中移除</p>
  </li>
  <li>
    <p>v-model 双向数据绑定， 用于表单元素 v-model:属性=&quot;数据&quot;，双向绑定实际上是一直监听 dom 跟虚拟 dom 中的差异，</p>
    <ol>
      <li>
        <p>input:text 默认绑定的是 value 如果是绑定 value 可以省略，</p>
      </li>
      <li>
        <p>checkbox 多选框也可以省略 默认绑定的是 checked，</p>
      </li>
      <li>
        <p>radio 单选框，v-model 绑定的值 会与 radio 中 value 中的值比较，如果相同的会选中</p>
      </li>
      <li>
        <p>select 下拉选择框 是在 select 绑定，绑定的是 option 元素上的 value 属性, 但相等就会被选中</p>
        <pre class="hljs"><code><div>&lt;select name=&quot;&quot; id=&quot;&quot; v-model=&quot;propname&quot;&gt;
   &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
   &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
   &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
   &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt;
&lt;/select&gt;
</div></code></pre>
      </li>
    </ol>
  </li>
</ol>
<h3 id="vue-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7">Vue 对象中的属性</h3>
<ol>
  <li>
    <p>data 数据 状态</p>
  </li>
  <li>
    <p>methods 方法</p>
  </li>
  <li>
    <p>props 是一个数组 用于接收父组件传来的参数</p>
  </li>
  <li>
    <p>watch 是个对象 监听同名 '数据'的改变</p>
  </li>
  <li>
    <p>components 组件 可以重复使用的自定义标签</p>
    <ol>
      <li>
        <p>定义</p>
        <ol>
          <li>
            <p>全局组件</p>
            <pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myBtn"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"change(-1)"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"num"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"change(+1)"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</div></code></pre>
            <pre class="hljs"><code><div><span class="hljs-keyword">var</span> componentMyBtn = {
  <span class="hljs-attr">template</span>: <span class="hljs-string">'#myBtn'</span>,
  data() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">num</span>: <span class="hljs-number">1</span>
    }
  },
  <span class="hljs-attr">methods</span>: {
    change(i) {
      <span class="hljs-keyword">this</span>.num += i
    }
  }
}
Vue.component(<span class="hljs-string">'my-btn'</span>, componentMyBtn)
</div></code></pre>
          </li>
          <li>
            <p>私有组件</p>
            <pre class="hljs"><code><div><span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">component</span>: {
    <span class="hljs-string">'my-btn'</span>: componentMyBtn
  }
})
</div></code></pre>
          </li>
        </ol>
        <h4 id="%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</h4>
        <ol>
          <li>在定义组件中的 data 是一个函数，返回一个 data 对象，这是为了组件多次使用数据相互独立</li>
          <li>在定义组件的时候全局组件的名称不要使用驼峰命名法， 在引用的时候 html 不会识别组件是大小写 如果是多个单词可以使用 - 连接， 如果是私有组件，可以用驼峰命名法，会自动的转换为 带 - 的</li>
          <li>template 中的 html 片段只能有一个跟元素 多了会报错,组件的内容如果相对简单的话，也可以直接写在 template 属性中</li>
        </ol>
      </li>
      <li>
        <p>使用</p>
        <ul>
          <li>&lt;组件名称&gt;&lt;/组件名称&gt;</li>
          <li>需要注意 需要在 #app 元素以内使用，如果是局部的组件，则需要在这个父组件的有效范围内使用</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>computed 计算属性 是个对象，对象中的成员是方法，这些方法都有一个共同的特性，将计算后的数据显示到页面上，但是原来的数据不会改变 方法需要 return 返回给这个函数， 在使用的时候同 data 中的数据 只需使用方法的名称 不是方法的调用，多次调用只计算一次，如果关心计算的结果，而不关心操作的过程使用 computed</p>
  </li>
  <li>
    <p>directives 自定义指令 , 使用 v-directivesName</p>
    <ol>
      <li>
        <p>如果 13 种指令不够用，可以创建指令</p>
        <ol>
          <li>
            <p>私有指令</p>
            <pre class="hljs"><code><div><span class="hljs-comment">// 在Vue 对象的实例中使用，</span>
<span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
  <span class="hljs-attr">data</span>: {},
  <span class="hljs-attr">methods</span>: {},
  <span class="hljs-attr">directives</span>: {
    <span class="hljs-string">'指令名(不需要加上-v)'</span>: {
      inserted(el) {
        <span class="hljs-comment">// 相关dom 操作</span>
      }
    }
  }
})
</div></code></pre>
          </li>
          <li>
            <p>全局指令</p>
            <pre class="hljs"><code><div>Vue.directive(
  <span class="hljs-string">'name'</span>, <span class="hljs-comment">//name 定义的时候不用使用-v</span>
  {
    inserted(elem) {
      <span class="hljs-comment">// elem 是加上指令的dom原生 在这里可以做一些dom 操作  需要使用原生 dom 的方法</span>
    }
  }
)
</div></code></pre>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p>filters 定义过滤器</p>
    <ol>
      <li>
        <p>对从模型中绑定的原生值，进行再加工后，再显示如果模型中的值不能直接使用，如使用时间这一类的，需要格式化</p>
      </li>
      <li>
        <p>使用 在需要转换的模型数组 {{dataProps | filterName(arg1)}}</p>
      </li>
      <li>
        <p>定义</p>
        <ol>
          <li>
            <p>全局</p>
            <pre class="hljs"><code><div>Vue.filter(<span class="hljs-string">'过滤器名称'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'data 的处理结果'</span>
})
</div></code></pre>
          </li>
          <li>
            <p>局部 (私有过滤器)</p>
            <pre class="hljs"><code><div><span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
  <span class="hljs-attr">filters</span>: {
    过滤器名称(data) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'data 的处理结果'</span>
    }
  }
})
</div></code></pre>
          </li>
        </ol>
        <p>使用注意点， 可给这个过滤器传入参数，但在定义的时候第一个参数永久是需要使用过滤器的数据，可以使用多个过滤器，需要注意，下一个过滤器的拿到的结果上一个处理的中间结果 173</p>
      </li>
    </ol>
  </li>
  <li>
    <p>生命周期函数</p>
    <ol>
      <li>create 创建阶段
        <ol>
          <li>beforeCreate</li>
          <li>create ----- 可以用来获取服务端的数据，不能操作 dom 元素，</li>
        </ol>
      </li>
      <li>mount 过载阶段
        <ol>
          <li>beforeMount</li>
          <li>mount ------ 可以用来操作 dom 操作</li>
        </ol>
      </li>
      <li>update 组件的模型数据更新阶段
        <ol>
          <li>beforeUpdate</li>
          <li>update</li>
        </ol>
      </li>
      <li>destroy 销毁阶段
        <ol>
          <li>beforeDestroy</li>
          <li>destroyed</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>
<h3 id="vue-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%A0%B7%E5%BC%8F%E5%92%8C-class">Vue 中设置样式和 class</h3>
<h4 id="style">style</h4>
<ol>
  <li>在为 style 绑定数据时，使用字符串拼接的方式</li>
  <li>绑定 style 传入一个对象 :style=&quot;{top:'100px',left:'100px'}&quot;, 如果需要动态的修改样式可以定义在 data 数据中，当属性中是多个单词可以使用驼峰，在设置的时候可以直接使用.语法</li>
  <li>数组的方式传入</li>
</ol>
<h4 id="class-%E7%BB%91%E5%AE%9A">class 绑定</h4>
<ol>
  <li>直接使用类名字符串拼接的方式，</li>
  <li>对象形式绑定，在定义这个对象时可以使用{类名: true/false}</li>
  <li>数组的方式传入</li>
</ol>
<h2 id="axios-%E7%94%A8%E4%BA%8E%E5%8F%91%E8%B5%B7-ajax-%E8%AF%B7%E6%B1%82-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-vue-resource">axios 用于发起 ajax 请求 (不推荐使用 vue-resource)</h2>
<ol>
  <li>
    <p>get 请求</p>
    <pre class="hljs"><code><div>axios
  .get(<span class="hljs-string">'url'</span>, {
    <span class="hljs-attr">params</span>: {
      <span class="hljs-attr">uname</span>: <span class="hljs-string">'dingding'</span>
    }
  })
  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.data)
</div></code></pre>
    <h3 id="%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</h3>
    <ol>
      <li>发送的参数是在 配置对象的 params 属性中</li>
      <li>返回的结果是响应报文 不单单是单独的 服务端的响应体 在 res 的 data 属性中</li>
      <li>如果需要发起请求如果需要带上 cookie 信息，需要设置 <code>axios.defaults.withCredentials = true</code> 4.可以设置所有请求的默认请求的 url <code>axios.defaults.baseURL = 'http://192.168.1.107:3000'</code> 方便维护</li>
    </ol>
  </li>
  <li>
    <p>post 请求</p>
    <pre class="hljs"><code><div>axios.post(<span class="hljs-string">'url'</span>, <span class="hljs-string">'传入的参数'</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(res.data)
})
</div></code></pre>
    <p>注意点 参数直接写在 post 方法的第二个参数中 ，可以是对象的方式也可以是字符串拼接的方式，如果传入参数有 BUG 时 可以引入 qs 模块 使用 qs 可以将对象转换成字符串的模式</p>
  </li>
</ol>
<h2 id="%E4%BC%A0%E5%8F%82%E3%80%81%E4%BC%A0%E5%85%A5%E6%96%B9%E6%B3%95">传参、传入方法</h2>
<ol>
  <li>
    <p>父组件向子属性传入参数</p>
    <ol>
      <li>父组件的 html 代码段中 在引用子组件使用 使用指令 <code>v-bind:name=&quot;属性&quot;</code> 绑定自定义属性</li>
      <li>子组件中，在子组件的参数中使用 <code>props</code> 属性接收，是一个数组 需要接收 <code>props:['name1', 'name2'...]</code></li>
    </ol>
  </li>
  <li>
    <p>父组件向子组件传递方法</p>
    <ol>
      <li>父组件 的 html 代码段中 使用指令 <code>v-on:func-name=&quot;方法名&quot;</code> 绑定自定义方法</li>
      <li>在需要调用的地方使用 <code>this.$emit( 'func-name'，'传入的参数',... )</code></li>
    </ol>
  </li>
</ol>
<h2 id="spa-single-page-application-%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%EF%BC%88%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%89-%E5%8F%AA%E6%98%AF%E5%88%87%E6%8D%A2%E9%A1%B5%E9%9D%A2">SPA single page Application 单页面应用程序 （只有一个页面） 只是切换页面</h2>
<ol>
  <li>
    <p>是根据 URL 中的锚点不同，切换组件，组件之间的切换是在客户端形成的， 需使用到路由器 <code>vue-router</code> ，单页面应用程序先对于页面的，</p>
    <ol>
      <li>优点
        <ul>
          <li>提高用户体验减少服务端压力，</li>
          <li>只更新替换部分 DOM 内容 不需要重建 DOM 树 ，而多页面每次加载的时候，都需要重复的请求相同的资源,</li>
          <li>页面与页面之间的切换可以由过渡的效果</li>
        </ul>
      </li>
      <li>缺点
        <ul>
          <li>请求首次首屏的加载速度慢，(可以在路由中设置延迟加载)</li>
          <li>不利于搜索引擎优化，爬虫可能爬不到</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>使用</p>
    <ol>
      <li>
        <p>插槽 <code>router-view</code> 标签 通过锚点判断显示对应的组件</p>
      </li>
      <li>
        <p><code>router-link</code> 跳转 <code>router</code></p>
      </li>
      <li>
        <p>定义路由表</p>
        <pre class="hljs"><code><div><span class="hljs-keyword">var</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">'/home'</span> }, <span class="hljs-comment">// redirect 地址重定向</span>
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>,
    <span class="hljs-attr">component</span>: home,
    <span class="hljs-attr">children</span>: [
      { <span class="hljs-attr">path</span>: <span class="hljs-string">'login'</span>, <span class="hljs-attr">component</span>: login },
      { <span class="hljs-attr">path</span>: <span class="hljs-string">'register'</span>, <span class="hljs-attr">component</span>: register }
    ]
  }, <span class="hljs-comment">//   component 是指向 组件对象， path 路由的地址</span>
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/*'</span>, <span class="hljs-attr">component</span>: error }
]
<span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> VueRouter({ routes })
</div></code></pre>
      </li>
      <li>
        <p>过载到组件中</p>
        <pre class="hljs"><code><div><span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">data</span>: {},
  <span class="hljs-attr">methods</span>: {},
  <span class="hljs-attr">components</span>: {},
  router <span class="hljs-comment">//件将路由过载到页面中，</span>
})
</div></code></pre>
      </li>
    </ol>
    <h4 id="%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC">路由跳转</h4>
    <ol>
      <li>
        <p>使用 标签跳转 <code>&lt;router-link to=&quot;路由路径&quot; tag=&quot;生成的标签&quot; &gt;&lt;/router-link&gt;</code></p>
        <ol>
          <li>默认是生成 a 标签 可以使用 <code>tag</code> 属性设置生成元素的类型</li>
        </ol>
      </li>
      <li>
        <p>使用 js 实现路由的跳转</p>
        <ol>
          <li>
            <p>在路由表过载的组件对象中，如果要实现路由的跳转，在这个组件对象中有一个 <code>$router.history</code> 或 <code>$router</code> 的原型中有 <code>go()</code> <code>push()</code> 等方法, history 用于 history 的跳转 但是在 hash 模式也可以使用 这些方法的用法类型与 window.history 中的属性跟方法相似， 可以使用这些方法实现路由 的跳转返回等功能</p>
            <pre class="hljs"><code><div><span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">'/home'</span>) <span class="hljs-comment">// 跳转到哈希路由为 home</span>
<span class="hljs-keyword">this</span>.$router.go(<span class="hljs-number">-1</span>) <span class="hljs-comment">//放回上一个路由 1为前进 0 为当前页面</span>
</div></code></pre>
          </li>
        </ol>
      </li>
      <li>
        <p>路由跳转的激活类（激活状态使用的类）</p>
        <ol>
          <li>
            <p>可以直接使用 router-link-active 类名进行设置样式 默认激活状态绑定是这个类名</p>
          </li>
          <li>
            <p>使用自定义类名 用于库自带的激活类</p>
            <ol>
              <li>在 vue-router 的实例对象中 有属性 <code>linkActiveClass</code> 这个属性是用于绑定激活类名的</li>
            </ol>
            <pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter({
  <span class="hljs-attr">linkActiveClass</span>: <span class="hljs-string">'mui-active'</span> <span class="hljs-comment">// 覆盖默认的选中高亮的类 默认的类叫做router-link-active</span>
})
</div></code></pre>
          </li>
        </ol>
      </li>
    </ol>
    <h4 id="%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%95%B0">路由传参数</h4>
    <ol>
      <li>
        <p>通过路径传入参数(修改路由表)</p>
        <ul>
          <li>
            <p>在定义路由表的时候</p>
            <pre class="hljs"><code><div><span class="hljs-keyword">var</span> router = <span class="hljs-keyword">new</span> VueRouter({
  <span class="hljs-attr">routes</span>: [{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/home/:lid'</span>, <span class="hljs-attr">component</span>: home, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> }] <span class="hljs-comment">// props:</span>
})
</div></code></pre>
          </li>
          <li>
            <p>在跳转路由中传入参数 跳转的路由链接设置为 '/home/2'</p>
          </li>
          <li>
            <p>接收传递过来的参数</p>
            <ol>
              <li>在该路由对应的组件可以使用 this.$route.params.lid 获取，</li>
              <li>如果设置了 <code>props</code> 为 <code>true</code> 会见传过来的参数传递给 props 中的同名属性 此时可以在对应组件的 props 属性接收，类似父组件向子组件传递参数</li>
            </ol>
          </li>
        </ul>
      </li>
      <li>
        <p>使用? 传参（类似 get 请求）</p>
        <ol>
          <li>
            <p>可以不用修改路由表</p>
            <ol>
              <li>如果要像以上一样传入 组件中的 props 属性 不能直接使用 props:true 需要使用</li>
            </ol>
            <pre class="hljs"><code><div>;[
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/home'</span>,
    <span class="hljs-attr">component</span>: home,
    <span class="hljs-attr">props</span>: <span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> ({ ...route.query })
  } <span class="hljs-comment">// props 属性可以是布尔值 也可以是方法 这个方法中的第一个参数是 $route 对象 可以使用 ...es6的语法将 route中的每个属性映射到对象中, 返回出去，也可以将query 返回出去，在组件对象的 props 中接收</span>
]
</div></code></pre>
          </li>
          <li>
            <p>传入的参数需要使用 <code>?uname=zs&amp;&amp;pwd=1122</code> 的方式传入</p>
          </li>
          <li>
            <p>在接收的时候需要使用 <code>$route.query.name</code> 接收</p>
          </li>
        </ol>
      </li>
    </ol>
    <h4 id="%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</h4>
    <ul>
      <li><code>component</code> 中是组件对象， 如果是在一个路由地址的子路由，</li>
      <li>这对应中的路由(routes 中的成员) 中的 <code>children</code> 属性中是个数组 在这里面之中可以写路由表,子路由中的 path 如果使用绝对路径的路由需要加父路由 (/开头) 也可以使用相对的(不是/ 开头的，直接写子路由对应的路由地址)</li>
      <li><code>vue-router</code> 在 vue 之中是没有内置的 需要下载引入</li>
      <li>路由表中路由路由项的 <code>props</code> 属性的作用：控制将传过来的属性传递对应组件中的 props 属性中，可以在组件中的 <code>props</code> 属性中接收对应的参数</li>
      <li>设置路由的跳转使用的是 <code>$router</code> 接收路由跳转传递的参数和路由当前路径 <code>$route.path</code> 是 <code>$route</code></li>
    </ul>
  </li>
</ol>
<h2 id="%E5%85%AC%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81-%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-vuex-%E6%8F%92%E4%BB%B6">公用的状态 需要使用 Vuex 插件</h2>
<ol>
  <li>
    <p>下载 <code>npm i vuex</code></p>
  </li>
  <li>
    <p>引入 <code>import Vuex from 'vuex'</code></p>
  </li>
  <li>
    <p>过载到 Vue.use 方法中 <code>Vue.use(Vuex)</code></p>
  </li>
  <li>
    <p>起步</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store({
  <span class="hljs-attr">state</span>: { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> },
  <span class="hljs-attr">mutations</span>: {
    increment(state) {
      state.count++
    }
  }
})
</div></code></pre>
  </li>
  <li>
    <p>过载到 vue 实例对象 中</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
  router,
  store, <span class="hljs-comment">//使用store</span>
  template: <span class="hljs-string">'&lt;App/&gt;'</span>,
  <span class="hljs-attr">components</span>: { App }
})
</div></code></pre>
    <ol>
      <li>修改状态，
        <ul>
          <li>修改状态的方法，需要在 store 的实例对象的 mutations 属性中定义 这是为了方便维护，</li>
          <li>需要调用修改数据的方法 可以 通过 <code>this.$store.commit('increment')</code> 调用</li>
        </ul>
      </li>
    </ol>
  </li>
</ol>
<h3 id="%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86-vuexstore-%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0">基本知识 (Vuex.Store 中的配置参数)</h3>
<ol>
  <li>
    <p>vuex 是vue项目的共享资源仓库, 当其中的一个组件修改了公用的状态，所有的组件的状态都会同步修改</p>
  </li>
  <li>
    <p><code>state</code> 状态 用于存储公用的数据 （data）</p>
  </li>
  <li>
    <p><code>getters</code> 类似于 Vue 配置中的计算属性，可以将计算后的属性返回</p>
    <pre class="hljs"><code><div><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store({
  <span class="hljs-attr">state</span>: {
    <span class="hljs-attr">todos</span>: [
      { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'...'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> },
      { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'...'</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> }
    ]
  },
  <span class="hljs-attr">getters</span>: {
    <span class="hljs-attr">doneTodos</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)
    }
  }
})
</div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">this</span>.store.getters.doneTodos <span class="hljs-comment">// -&gt; [{ id: 1, text: '...', done: true }]</span>
</div></code></pre>
    <ul>
      <li>可以传入参数给这个函数的第二个参数，第一个参数默认是数据源</li>
    </ul>
  </li>
  <li>
    <p><code>mutation</code> 用于定义修改数据的方法，所有修改数据的方法都应该在这里定义， 调用这些方法可以使用 <code>this.$store.commit('increment')</code> 可以传递参数到函数的第二个参数中，（第一个参数默认是 <code>state</code>）方法只能传入一个参数，如果需要传入多个变量，可以将这些变量拼接成一个对象的形式传入，只能是同步的操作</p>
    <pre class="hljs"><code><div><span class="hljs-comment">// ...</span>
mutations: {
  increment (state, n) {
  state.count += n
  }
}
</div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">this</span>.store.commit(<span class="hljs-string">'increment'</span>, <span class="hljs-number">10</span>)
</div></code></pre>
  </li>
  <li>
    <p><code>action</code> 类似于 <code>mutation</code> 但是 action 提交的是 mutation 而不是直接改变，可以进行异步上的数据处理</p>
    <pre class="hljs"><code><div> actions: {
   incrementAsync ({ commit }) {
     setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
       commit(<span class="hljs-string">'increment'</span>)
     }, <span class="hljs-number">1000</span>)
   }
 }
</div></code></pre>
    <pre class="hljs"><code><div><span class="hljs-keyword">this</span>.store.dispatch(<span class="hljs-string">'increment'</span>)
</div></code></pre>
    <ol>
      <li>传入的参数 与 mutation 中的方法
        相同</li>
    </ol>
  </li>
  <li>
    <p><code>module</code> 当需要管理的公用的数据相对比较多时，可以拆分成一个个模块，方便管理</p>
    <pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> moduleA = {
    <span class="hljs-attr">state</span>: { ... },
    <span class="hljs-attr">mutations</span>: { ... },
    <span class="hljs-attr">actions</span>: { ... },
    <span class="hljs-attr">getters</span>: { ... }
  }

  <span class="hljs-keyword">const</span> moduleB = {
    <span class="hljs-attr">state</span>: { ... },
    <span class="hljs-attr">mutations</span>: { ... },
    <span class="hljs-attr">actions</span>: { ... }
  }

  <span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store({
    <span class="hljs-attr">modules</span>: {
      <span class="hljs-attr">a</span>: moduleA,
      <span class="hljs-attr">b</span>: moduleB
    }
  })

  store.state.a <span class="hljs-comment">// -&gt; moduleA 的状态</span>
  store.state.b <span class="hljs-comment">// -&gt; moduleB 的状态</span>
</div></code></pre>
  </li>
</ol>
<h2 id="%E8%8E%B7%E5%8F%96%E5%AD%90%E7%BB%84%E4%BB%B6%E6%88%96%E8%8E%B7%E5%8F%96-dom-%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C-dom">获取子组件或获取 DOM 元素操作 DOM</h2>
<ol>
  <li>在父组件 html 中 使用 ref 属性 <code>ref=&quot;ref-name&quot;</code></li>
  <li>在需要访问这个属性的地方使用 <code>this.$ref['ref-name']</code> 此时这个获取到的 就是组件对象，或者是 原生 dom 对象</li>
</ol>
<h2 id="%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91">组件化开发</h2>
<h3 id="%E4%BC%98%E7%82%B9">优点</h3>
<ol>
  <li>可以拆分成多个文件开发，提高开发的效率</li>
  <li>松耦合，有一个组件出问题，可以推后发行，也更方便查找 bug</li>
</ol>
<h3 id="%E7%BD%91%E9%A1%B5%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E7%9A%84%E8%BF%87%E7%A8%8B">网页组件化开发的过程</h3>
<ol>
  <li>对这个网页进行组件划分</li>
  <li>再对其组件进行编辑</li>
  <li>将写好的组件组成一个网页</li>
  <li>使用 nodejs 中的 VueCli 编译</li>
</ol>
<h2 id="%E8%84%9A%E6%89%8B%E6%9E%B6-vue-cli">脚手架 vue-cli</h2>
<ol>
  <li>
    <p>全局安装</p>
    <ol>
      <li><code>npm i @vue/cli -g</code></li>
    </ol>
  </li>
  <li>
    <p>创建项目</p>
    <ol>
      <li><code>vue create project_name</code></li>
      <li>选择使用的插件 可以选择 Manually select features(自己选择)</li>
      <li>选择必要项（一般选择） babel router vuex (linter / Formatter)需要关闭，语法检查比较狠 if 后必须有空格 在接()</li>
      <li>选择是否使用 history mode 进行路由跳转（如果没有服务端的支持输入 n，因为需要在服务端使用重定向将修改客户端的 url 地址重新跳转到客户端认识的哈希路由）优点 不会跟后使用到锚点冲突，但是需要有服务端的配置</li>
      <li>选择生成项目的配置文件 分别在多个文件中，还是只生成一个配置文件 选择 <code>In package.json</code> 一个配置文件</li>
      <li>设置将来生成的项目首选这个配置 （n）</li>
    </ol>
  </li>
  <li>
    <p>目录结构</p>
    <ol>
      <li>public 需要保持原样的文件，如 img，html,第三方 js 库</li>
      <li>src 是需要编译的文件
        <ol>
          <li>assets 公共文件</li>
          <li>components 共享资源的组件</li>
          <li>views 中放置页面的组件 对应路由的列表</li>
          <li>main.js 脚手架 入口文件</li>
        </ol>
      </li>
      <li>package.json npm 的配置文件 可以用来修改启动命名，port host --hot 等</li>
    </ol>
  </li>
  <li>
    <p>安装 loader</p>
    <ol>
      <li>
        <p>安装 样式类的直接安装系统会默认帮我们配置</p>
        <ol>
          <li>
            <p>Sass(loader 的版本需要安装 7 以下的 8 以上最新的不支持)</p>
            <p><code>npm install -D sass-loader@7 sass</code></p>
          </li>
          <li>
            <p>Less</p>
            <p><code>npm install -D less-loader less</code></p>
          </li>
          <li>
            <p>Stylus
              <code>npm install -D stylus-loader stylus</code></p>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p>注意点，在 css 中的 url 中必须使用绝对路径 / 开头</p>
  </li>
  <li>
    <p>引入公用的 css 文件</p>
    <ol>
      <li>使用 import 引入文件的 import '@/assets/css/base.css' @指向 src 是 src 的别称，在跟路由对应的组件中引入，引入后会自动的生成在内部样式中</li>
    </ol>
  </li>
  <li>
    <p>axios 发起 ajax 请求注意点</p>
    <ol>
      <li>引入 <code>import axios from 'axios'</code></li>
      <li>设置发起 ajax 可以带 <code>cookie axios.defaults.withCredentials = true</code> jquery 中发起 ajax 请求， 如果需要携带 cookie 则需要在配置对象中设置<code>withCredentials: true</code> 才能携带 cookie</li>
      <li>过载到 Vue 的原型对象中 <code>Vue.prototype.axios=axios</code></li>
    </ol>
  </li>
</ol>
<h2 id="%E7%BB%84%E4%BB%B6%E5%BA%93">组件库</h2>
<ol>
  <li>
    <p>mint-ui 组件库 基于 vue</p>
    <ol>
      <li>loadmove 组件需要为这个组件的父组件设置高度</li>
      <li>轮播图组件需要设置高度，如果希望屏幕的放大缩小图片的有自适应高度的功能可以使用 vw 单位，基于视口宽度大小，</li>
    </ol>
  </li>
  <li>
    <p>mui 不是基于 vue 需要取消代码的严格模式</p>
  </li>
</ol>

</body>
</html>
